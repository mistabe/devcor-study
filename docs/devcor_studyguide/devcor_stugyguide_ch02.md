# Cisco DEVCOR 350-901 Study Guide

<https://www.ciscopress.com/store/cisco-devnet-professional-devcor-350-901-study-guide-9780137500048>

## Using APIs

Synchronous and Asynchronous is the lingua franca here. Synchronous is more familiar in terms of modernity but asynchronous has certain virtues assuming you've designed your requesting application and service to support parallel request execution and identification of requests using GUIDs etc.

### 2.1 Implement robust REST API error handling for timeouts and rate limits

- Create the request client side
- Transfer the request across the network to the server
- Execute the request at the server
- Transfer the response over the network to the client

In the above stages, you can suffer both network and API errors, indicated by HTTP response codes.

Timeouts need to be managed. Either the network is slow or the server is busy. Tuning the timeout if the network is slow is acceptable, but if the server is busy a longer timeout would create poor user experience.

Exponential back off timers are preferred.

- connection timeout
- initial wait time
- wait reset time

Are the three parameters to modify the exponential back off value.
Starts with the _initial wait time_ then doubles continuosusly until the wait reset time is hit when it's reset back to the initial value. 

An example but quite unlikely backoff timer:

- 1s, 2s, 4s, 8s, 16s

Be aware of the type of HTTP method you're using when working with timeouts. HTTP POST methods are not idempotent, so calling that method many times would result in many entires of a thing. The same can't be said for all the idempotent methods which won't have any system consequence for frequnt attempts, the value of the response won't be changed by the number of methods attempted.

- 1xx Informational
- 2xx Success
- 3xx Redirection
- 4xx Client Error
- 5xx Server Error

HTTP 429 code is "Too many requests" which could be generated by your API gateway which adds the policy wrapper around your service.

### 2.2 Implememt control flow of consumer code for unrecoverable REST API errors

Recoverable and Unrecoverable errors are the two problems whence one shall encounter when creating the control flow in your code.

Unrecoverable errors require some kind of manual interaction to continue.

Recoverable errors should be able to be handled with code logic.

Unrecoverable Client Error examples:

- 400 Bad Request: Your request is shoddy and needs finessing.
- 401 Unauthorized: Authentication using a key, token or other safe method is required. 
- 403 Forbidden: You're authenticated but not permitted to the resource.

Recoverable errors:

- 405 Method not allowed:
- 408 Timeout:
- 429 Too Many Requests: 

### 2.3 Identify ways to optimse usage through HTTP cache controls

APIs grow, and when they do you can use the scaling techniques from the previous module. 
Notably, you can also implement pagination which can have a major affect on your API resources as your usage and datasets grow.

**HTTP Caching**

Typically only used for servivcing HTTP GET requests.
Implented at - the client, local proxy server, reverse proxy or an API Gateway. Has the concept of "freshness" to balance content refresh over network and resource usage.

If the cache content has not expired as determined in the header, then it's fresh, otherwise it's stale.

HTTP Headers are used as a "cheap" way of determining if stale content is still valid.

- The date of last modifiation of the document
- ETag / Entity Tags in the "ETag" HTTTP Header

**HTTP Conditional Requests**

A conditional requests passes ETag headers to the service which were received from the original request to allow the service to ascertain whether to bother sending fresh content.
By default, strong validators are used but one can define them as weak if supported. See [HTTP ETag](https://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation)


`If-None-Match:`

`If-Modified-Since:`

Will both be used in the HTTP PUT from client to upstream service to determine if those values are different from what is provided, to send fresh content.

Either a HTTP 204 No Content or a HTTP 412 Precondition Failed will be provided back.

**Caching Controls**

The [Cache-Control HTTP Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) modifies cache behaviour _some_ of the options are listed here:

- no-store
- no-cache
- max-age=\<seconds>
- public
- private

To make use of the Cache-Control header, append one or more of the above attributes to the word as so:

Prevents caching of a resource

`Cache-Control: no-store`

Caching static assets

`Cache-Control: public, max-age=604800, immutable`

**HTTP Data Compression**

[Headers which indicate compression](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding) can be users are "Accept-Encoding".
Compression signals are optional and can be ignored by devices in the flow.

Compress, deflate, bzip2 and gzip are accepted parameters. 

A client would send acceptable options in the request like:

`Accept-Encoding: gzip, deflate`

The server if it decides to compress would then respond in the response with:

`Content-Encoding: gzip`

### 2.4 Construct an application that consumes a REST API that supports pagination

One needs to be efficient with responses to requests. In that spirit pagination is effective in both saving resources on the server side, reducing network bandwidth and serving content on demand rather than all at once, overwhelming or simply making the client disinterested.

The client can determine the pagination offered as such:

`https://www.bob.com/events?offset=100&limit=20`: Returns 20 entries, starting with 100th

`https://www.bob.com/events?page=6&per_page=20`: Same logic, different syntax

Issues with this method include the dataset being updated on the server between requests. So you'll receive confusing results which will be considered poor form. If the dataset is static however, or infrequently updated with little consumer consequence, then maybe this is fine.

_Cursor_ or _Keyset_ based methods address the drawbacks above.
You can imagine the [Slack](https://slack.com/intl/en-gb/) client using this method to state from where in each channel new messages start.

Similarly, here's the Webex Teams version of that implementation:

`https://webexapis.com/v1/messages?roomId={room}&max=5&before=2020-07-07T12:34:00`

`https://webexapis.com/v1/messages?roomId={room}&max=5&beforeMessage=ZBCdefXYZ`

Even with the above you can improve upon it as REST APIs have a way to simplify this process by providing additional information in the HTTP headers or responses.

[HTTP "Link" header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link) which uses "links" and "relationships". The link must be provided in angled brackets \<> and the relationship defined with the key `rel=`

Example:

```http
Link: <https://www.bob.com/events?offset=100&limit=20>; rel="self",
<https://www.bob.com/events?offset=80&limit=20>; rel="prev",
<https://www.bob.com/events?offset=120&limit=20>; rel="next",
<https://www.bob.com/events?offset=0&limit=20>; rel="first",
<https://www.bob.com/events?offset=220&limit=20>; rel="last"
```

You can also incllude metadata directly in the REST API response body.

```python
"paging": {
    "offset": 6,
    "limit": 2,
    "count": 42,
    "prev": [
      "https://fmcrestapisandbox.cisco.com/api/fmc_config/v1/domain/e276abec-e0f2-11e3-8169-6d9ed49b625f/object/applicationcategories?offset=4&limit=2",
      "https://fmcrestapisandbox.cisco.com/api/fmc_config/v1/domain/e276abec-e0f2-11e3-8169-6d9ed49b625f/object/applicationcategories?offset=2&limit=2",
      "https://fmcrestapisandbox.cisco.com/api/fmc_config/v1/domain/e276abec-e0f2-11e3-8169-6d9ed49b625f/object/applicationcategories?offset=0&limit=2"
    ],
    "next": [
      "https://fmcrestapisandbox.cisco.com/api/fmc_config/v1/domain/e276abec-e0f2-11e3-8169-6d9ed49b625f/object/applicationcategories?offset=8&limit=2",
      "https://fmcrestapisandbox.cisco.com/api/fmc_config/v1/domain/e276abec-e0f2-11e3-8169-6d9ed49b625f/object/applicationcategories?offset=10&limit=2",
      "https://fmcrestapisandbox.cisco.com/api/fmc_config/v1/domain/e276abec-e0f2-11e3-8169-6d9ed49b625f/object/applicationcategories?offset=12&limit=2",
      "https://fmcrestapisandbox.cisco.com/api/fmc_config/v1/domain/e276abec-e0f2-11e3-8169-6d9ed49b625f/object/applicationcategories?offset=14&limit=2"
    ],
    "pages": 21
```

### 2.5 Describe the steps in the OAuth2 three legged authorization code grant flow

In traditional circumstances with client/server apps, the client authenticates with the resource owner's creds when it requests a restricted resource on a server.
When a third party app requires access to resources, the resource owner has to share creds, which creates problematic issues.

OAuth addreseses these shortcomings and introduces an authorization layer and seperating the roles of the client and resource owner

OAuth2 defines four roles;

- Resource Owner
- Client
- Resource Server
- Authorization Server

OAuth is deisgned for use with HTTP and specifies several different _authorization grant_ types to address different use cases and device capcabilities.

There's two legged and three legged variants referring to the numbers of parties involved in the authentication process. The two legged varient doesn't involve user intereaction and is typically used for machine to machine authorization.

To be able to use OAuth, the client application must first be regsitered with the authorization provider. This in Azure is _App Registrations_ The auth provider may request information like the client application name, description, icon, and the application redirect URL for the actual security.

Azure will issue GUIDs for Application (Client) ID, Object ID and Directory (Tenant) ID. The client ID is used by the service API (!?) to identify the application (like a username) and the client secret is used to authenticate the idenitity of the application and must be kept private between the client application and the API.

- Authorization Code grant - Three legged
- Client Credentials grant - Two legged
- Refresh Token grant - Refresh token without reauth
- Devide Code grant - Used on browserless devices
- Password credentials grant - (legacy) the users creds are exchanged for an access token

**Authorization Code Grant Flow**

[MS Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow) describe the flow well